<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BJZ Beat 'em Up — Skeleton</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js" integrity="sha512-zQK11u7QyhUWLmhK+Kyn4Oac0n2d5+AcuEiCagfm2YrGa2wMrdbj5EJammEmGU7bGnckmRoNTUT29Dl+DaRSlg==" crossorigin="anonymous"></script>
</head>
<body>
<script>
/*
 * ============================================================
 *  README — FEATURE 8H (Parallax Background)
 * ============================================================
 *
 *  SUMMARY OF CHANGES:
 *    - Feature 8H: Implemented 3-layer parallax background.
 *    - Slicing: assets/parallax_pack.png is sliced into Far, Mid, Near textures via canvas.
 *    - Layers: farTS (sky/tissue), midTS (vessels), nearTS (bubbles/cells).
 *    - Pacing: worldWidth expanded to 8000px for extensive side-scrolling.
 *    - Fallback: Mid/Near layers use semi-alpha (0.75) and SCREEN/ADD blend for checkerboard.
 *
 *  TESTING INSTRUCTIONS:
 *    - Pohybuj se doprava: Sky se hýbe pomalu, bubliny v popředí rychle.
 *    - Ověř HUD (V8H): Sloupce CAM a PL ukazují průběh světa, PARALLAX ukazuje posun vrstev.
 *    - Resize: Změň velikost okna a ověř, že pozadí stále pokrývá celý viewport.
 *
 *
 * ============================================================
 */

// ============================================================
//  A) BJZ NAMESPACE & INIT
// ============================================================
window.BJZ = window.BJZ || {};

BJZ.deepFreeze = function(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    Object.keys(obj).forEach(prop => {
        if (obj[prop] && typeof obj[prop] === 'object' && !Object.isFrozen(obj[prop])) {
            BJZ.deepFreeze(obj[prop]);
        }
    });
    return Object.freeze(obj);
};

BJZ.initCfgOnce = function() {
    if (BJZ.cfg) return; 
    
    BJZ.cfg = {
        gameWidth: 800,
        gameHeight: 450,
        worldWidth: 8000, // PROMPT 8H: side-scroller expansion
        worldHeight: 450,
        laneTop: 250,
        laneBottom: 360,
        
        playerSpeedX: 260,
        playerSpeedY: 160,
        
        // PROMPT 8B: Enemy Varieties & Spawning
        enemies: {
            types: {
                GRUNT: {
                    label: "GRUNT", color: 0x22cc44, hpMax: 60, moveSpeedX: 95, moveSpeedY: 70,
                    stopDistX: 55, windupMs: 220, hitWindowMs: 140,
                    touchDamage: 6, touchCooldownMs: 900, knockbackPxOnA2: 20,
                    cost: 1 // PROMPT 8G
                },
                TANK: {
                    label: "TANK", color: 0x33aa77, hpMax: 140, moveSpeedX: 65, moveSpeedY: 50,
                    stopDistX: 70, windupMs: 320, hitWindowMs: 160,
                    touchDamage: 10, touchCooldownMs: 1100, knockbackPxOnA2: 10,
                    cost: 3 // PROMPT 8G
                }
            },
            spawn: [
                { key: "e1", type: "GRUNT", x: 600, y: 280 },
                { key: "e2", type: "TANK", x: 1400, y: 320 }
            ]
        },

        // PROMPT 8G: Spawning & Pacing Tuning
        spawning: {
            enabled: true,
            maxAlive: 3,
            respawnDelayMs: 2200,
            initialSpawnDelayMs: 0,
            scorePerKill: 50,
            scalePerWave: { hpMul: 1.06, dmgMul: 1.03, speedMul: 1.02 },
            
            // Fairness & Selection
            minDistFromPlayer: 130, 
            minDistFromOtherEnemy: 70,
            rMin: 180, rMax: 330,
            breatherAfterHitMs: 700,
            typeWeights: { GRUNT: 0.75, TANK: 0.25 },
            
            tickMs: 450, // PROMPT 8G.2
            // Wave structure
            wave: {
                baseBudget: 4,
                budgetPerWave: 3,
                baseKillsGoal: 3,
                killsPerWave: 2,
                breatherMsMin: 900,
                breatherMsMax: 1500
            },

            // PROMPT 8H: Parallax Speeds
            parallax: {
                speeds: { far: 0.15, mid: 0.35, near: 0.65 }
            }
        },

        // PROMPT 7B: Knockback (Player only now)
        playerKnockbackMs: 140,
        playerKnockbackSpeed: 220,
        
        // PROMPT 7A: Player Hit Config (Preserved)
        playerHitInvulnMs: 600,
        playerRespawnMs: 3000,
        playerDownAlpha: 0.25,
        
        // PROMPT 6: AI Lane Snap (used globally)
        ai: {
            laneSnapDistY: 6
        },
        
        a1: {
            cooldownMs: 250,
            damage: 10,
            duration: 150,
            hitboxX: 45,
            hitboxY: 5,
            width: 60,
            height: 40
        },
        a2: {
            cooldownMs: 450,
            damage: 18,
            duration: 160,
            hitboxX: 55,
            hitboxY: 6,
            width: 90,
            height: 55,
            knockbackPx: 18,
            invulnMs: 200
        },
        super: {
            cooldownMs: 1500,
            damage: 30,
            radius: 90,
            invulnMs: 250,
            chargeRate: 5,
            max: 100
        },
        
        colors: {
            enemy: 0x22cc44,
            enemyWindup: 0x66ff88,
            obstacle: 0x888888,
            player: 0xffffff,
            hitFlash: 0x88ff88,
            hitFlashAlpha: 0.5
        },

        ui: {
            flashAlpha: 0.22,
            flashDuration: 180
        },

        juice: {
            enabled: true,
            hitstop: {
                enabled: true,
                maxMs: 120,
                a1Ms: 35,
                a2Ms: 55,
                superMs: 90,
                playerHitMs: 45
            },
            shake: {
                enabled: true,
                a1: { dur: 70, inten: 0.0025 },
                a2: { dur: 90, inten: 0.0035 },
                super: { dur: 140, inten: 0.0050 },
                playerHit: { dur: 90, inten: 0.0030 }
            },
            impactPulse: {
                enabled: true,
                durMs: 120,
                alphaFrom: 0.25,
                alphaTo: 0.0
            }
        },

        dev: {
            arcadeDebug: false,
            barMarkersOn: true, // PROMPT 8: Visual self-test markers
            exposeGlobals: false // PROMPT 8E: Gate for window.gameScene
        }
    };
    
    BJZ.deepFreeze(BJZ.cfg);
    console.log("BJZ CFG DEEP FROZEN");
};

BJZ.initStateOnce = function() {
    if (BJZ.state) return;
    
    BJZ.state = {
        playerHP: 300,
        playerHPMax: 300,
        super: 0,
        superReady: false,
        bossHP: 1000,
        bossHPMax: 1000,
        score: 0,
        timeSeconds: 0,
        
        // PROMPT 8A: Hit Feedback State
        hitstopMs: 0,
        hitstopReason: "",

        // PROMPT 7B: Knockback state
        playerKnockMs: 0,
        playerKnockVx: 0,
        
        // PROMPT 7A: Player Damage State
        playerInvulnMs: 0,
        playerHitCount: 0,
        lastPlayerHitBy: "",
        playerAlive: true,
        playerDownTimeMs: 0,
        
        // PROMPT 8G: Spawn Manager State (Upgraded)
        spawn: {
            wave: 1,
            wavePhase: "build", // "build", "clear", "breather"
            waveTimerMs: 0,
            waveBudget: 0,
            waveRemainingBudget: 0,
            waveKillsGoal: 0,
            killsThisWave: 0,
            totalKills: 0,
            lastWaveStartMs: 0,
            noSpawnUntilMs: 0,

            aliveCount: 0,
            lastSpawnTime: 0,
            queued: [] 
        },

        // PROMPT 8H: Parallax State
        parallax: {
            lastScrollX: 0
        },

        enemies: {
            // Populated during Scene.create from cfg.enemies.spawn
        },
        
        cooldownMs: { a1: 0, a2: 0, super: 0 },
        
        stats: { a1Fires: 0, a2Fires: 0, superFires: 0 },
        lastAction: "",
        lastInputEvent: "",
        
        debug: {
            playerX: 0, playerY: 0, vx: 0, vy: 0, facing: 1,
            isPhysicsPlayer: false,
            collisions: { playerEnemy: 0, playerObstacle: 0, a1Hit: 0 },
            a1Latency: 0, a2Latency: 0,
            lastSuperHits: {}, // PROMPT 8E: Dynamic map
            ai: { e1: "", e2: "" },
            lastPlayerHitTime: 0,
            dodges: 0, // PROMPT 7B: Dodge counter
            attackTrace: "",
            inRangeE1: 0, inRangeE2: 0,
            hitstopCount: 0, // PROMPT 8A
            spawnLog: "", // PROMPT 8C
            configFrozen: 1, // PROMPT 8D
            collPairs: 0, // PROMPT 8D (Deprecated)
            a1MapSize: 0, a2MapSize: 0, // PROMPT 8E
            enemyColliderMode: "GROUP", // PROMPT 8F
            aliveGuardOk: 1, // PROMPT 8F
            lastSpawnTryCount: 0,
            lastSpawnPickReason: ""
        }
    };
    
    window.gameState = BJZ.state;
};

BJZ.initInputOnce = function() {
    if (BJZ.input) return;
    BJZ.input = {
        attack1: false, attack2: false, super: false,
        moveX: 0, moveY: 0, moveMag: 0, moving: false,
        joyPointerId: null, joyUpdates: 0,
        touch: { attack1: false, attack2: false, super: false },
        kb: { left:false, right:false, up:false, down:false, attack1:false, attack2:false, super:false },
        a1WasDown: false, a1Pressed: false,
        a2WasDown: false, a2Pressed: false,
        supWasDown: false, supPressed: false,
        lastA1PressTime: 0, lastA2PressTime: 0
    };
    BJZ.state.input = BJZ.input; 
};

BJZ.initCfgOnce();
BJZ.initStateOnce();
BJZ.initInputOnce();


// ============================================================
//  GAME SCENE
// ============================================================
var GameScene = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize: function GameScene() {
        Phaser.Scene.call(this, { key: 'GameScene' });
        this.playerW = 40; this.playerH = 60;
        this.playerFacing = 1; 
        this.bossDeadPendingReset = false;
        this.playerDeadPendingReset = false;
        this._collFrameEnemy = -1;
        this._collFrameObstacle = -1;
        this._a1HitThisFire = {};
        this._a2HitThisFire = {};
        this.enemyRects = {};
        this.enemyHpTexts = {};
        this.enemyKeyPool = ["e1","e2","e3","e4","e5"];
    },

    preload: function() {
        this.load.image('parallax_pack', 'assets/parallax_pack.png');
    },

    forEachAliveEnemy: function(fn) {
        var st = BJZ.state;
        for (var i = 0; i < this.enemyKeyPool.length; i++) {
            var k = this.enemyKeyPool[i];
            var rect = this.enemyRects[k];
            var en = st.enemies[k];
            if (en && en.hp > 0 && rect && rect.body && rect.body.enable) {
                fn(k, rect, en);
            }
        }
    },
    
    isAliveRect: function(rect) {
        return !!(rect && rect.scene && rect.body && rect.body.enable);
    },

    create: function () {
        var cfg = BJZ.cfg; var st = BJZ.state;
        this.physics.world.setBounds(0, 0, cfg.worldWidth, cfg.worldHeight);

        this.keys = this.input.keyboard.addKeys({
            left:'LEFT', right:'RIGHT', up:'UP', down:'DOWN',
            a:'A', d:'D', w:'W', s:'S',
            j:'J', k:'K', l:'L'
        });

        this.cameras.main.setBounds(0, 0, cfg.worldWidth, cfg.worldHeight);

        // ---- Background ----
        this.bgGraphics = this.add.graphics().setDepth(-100);
        this.bgGraphics.fillStyle(0x222233, 1);
        this.bgGraphics.fillRect(0, 0, cfg.worldWidth, cfg.worldHeight);
        
        // PROMPT 8H: Parallax Texture Slicing
        var img = this.textures.get('parallax_pack').getSourceImage();
        console.log("PARALLAX_IMG_LOADED:", !!img, "W:", img ? img.width : 'N/A', "H:", img ? img.height : 'N/A');
        var stripH = Math.floor(img.height / 3);
        
        var createStrip = (name, index) => {
            var canvas = document.createElement('canvas');
            canvas.width = img.width; canvas.height = stripH;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, index * stripH, img.width, stripH, 0, 0, img.width, stripH);
            this.textures.addCanvas(name, canvas);
        };
        
        createStrip('bg_far', 0);
        createStrip('bg_mid', 1);
        createStrip('bg_near', 2);

        // PROMPT 8H: Parallax Layers
        this.farTS = this.add.tileSprite(0, 0, cfg.gameWidth, cfg.gameHeight, 'bg_far').setOrigin(0,0).setScrollFactor(0).setDepth(-10);
        this.midTS = this.add.tileSprite(0, 0, cfg.gameWidth, cfg.gameHeight, 'bg_mid').setOrigin(0,0).setScrollFactor(0).setDepth(-9);
        this.nearTS = this.add.tileSprite(0, 0, cfg.gameWidth, cfg.gameHeight, 'bg_near').setOrigin(0,0).setScrollFactor(0).setDepth(-8);
        
        // PROMPT 8H: Alpha/Blend Fallback (Removed blend modes for debugging)
        this.midTS.setAlpha(1.0);
        this.nearTS.setAlpha(1.0);

        this.bgGraphics.fillStyle(0x333344, 0.4); // Made semi-transparent to see sky
        this.bgGraphics.fillRect(0, 200, cfg.worldWidth, 250);
        this.bgGraphics.fillStyle(0x555566, 1);
        for (var i = 0; i < cfg.worldWidth; i += 200) this.bgGraphics.fillRect(i, 420, 80, 6);
        this.bgGraphics.fillStyle(0x444455, 0.5);
        for (var j = 0; j < cfg.worldWidth; j += 400) this.bgGraphics.fillRect(j, 0, 2, cfg.worldHeight);

        // PROMPT 8H: Resize listener
        this.scale.on('resize', (gameSize) => {
            var w = gameSize.width; var h = gameSize.height;
            if (this.farTS) this.farTS.setSize(w, h);
            if (this.midTS) this.midTS.setSize(w, h);
            if (this.nearTS) this.nearTS.setSize(w, h);
        });

        // PROMPT 8F: Optimized Group Colliders (O(n) instead of O(n^2))
        this.enemyGroup = this.physics.add.group();
        this.physics.add.collider(this.enemyGroup, this.enemyGroup); // Self-collide group

        // --- ENEMY INITIALIZATION (Requires enemyGroup) ---
        cfg.enemies.spawn.forEach(entry => {
            this.spawnEnemyInstance(entry.type, entry.x, entry.y, entry.key);
        });

        // Obstacle
        this.obstacleRect = this.add.rectangle(900, 335, 120, 50, cfg.colors.obstacle);
        this.physics.add.existing(this.obstacleRect, true); 

        // PLAYER
        this.playerRect = this.add.rectangle(100, 300, this.playerW, this.playerH, cfg.colors.player);
        this.physics.add.existing(this.playerRect, false);
        this.playerRect.body.setAllowGravity(false).setCollideWorldBounds(true);
        
        this.facingText = this.add.text(0, 0, ">", { 
            fontFamily: 'monospace', fontSize: '20px', color: '#00ff00', fontStyle: 'bold' 
        }).setOrigin(0.5);
        this.cameras.main.startFollow(this.playerRect, true, 0.08, 0.08);

        this.playerLabel = this.add.text(100, 250, '', {
            fontFamily: 'monospace', fontSize: '10px', color: '#ffffff'
        }).setOrigin(0.5);

        this.pHpText = this.add.text(0, 0, '', {
            fontFamily: 'monospace', fontSize: '10px', color: '#ffffff'
        }).setOrigin(0.5);
        
        // Hitboxes
        this.a1Hitbox = this.add.rectangle(-1000, -1000, cfg.a1.width, cfg.a1.height, 0xff0000, 0.2); 
        this.physics.add.existing(this.a1Hitbox, false);
        this.a1Hitbox.body.setAllowGravity(false).setEnable(false); 
        
        this.a2Hitbox = this.add.rectangle(-1000, -1000, cfg.a2.width, cfg.a2.height, 0x00ffff, 0.12);
        this.physics.add.existing(this.a2Hitbox, false);
        this.a2Hitbox.body.setAllowGravity(false).setEnable(false);

        // Physics
        this.physics.add.collider(this.playerRect, this.obstacleRect, this.onPlayerObstacle, null, this);
        this.physics.add.collider(this.enemyGroup, this.obstacleRect); // BUGFIX 8G.1: Order fix

        // BUGFIX 8G.1: Sustainable Group Overlaps for A1/A2
        this.physics.add.overlap(this.a1Hitbox, this.enemyGroup, (hb, rect) => {
            var k = rect.getData('key');
            if (k && !this._a1HitThisFire[k]) {
                this._a1HitThisFire[k] = true;
                BJZ.state.debug.a1MapSize++;
                this.applyDamageToEnemy(k, rect);
            }
        }, null, this);
        this.physics.add.overlap(this.a2Hitbox, this.enemyGroup, (hb, rect) => {
            var k = rect.getData('key');
            if (k) this.handleA2Hit(k, rect);
        }, null, this);

        this.time.addEvent({ delay: 1000, loop: true, callback: this.gameTick, callbackScope: this });
        this.scene.launch('HudScene');
        if (cfg.dev.exposeGlobals) window.gameScene = this; 
        
        console.log("PHASER_VER:", Phaser.VERSION);
        console.log("CFG_FROZEN_ROOT:", Object.isFrozen(BJZ.cfg));
        console.log("EXPOSE_GLOBALS:", !!cfg.dev.exposeGlobals);
        if (typeof Phaser !== 'undefined' && Object.isFrozen(BJZ.cfg)) console.log("SRI_OK");

        // PROMPT 8G: Initial Wave
        this.initWave(st.spawn.wave);
        console.log("SPAWN_TICK_MS:", cfg.spawning.tickMs);
        console.log("SPAWN_WAVE_START:", st.spawn.wave, "BUDGET:", st.spawn.waveBudget, "GOAL:", st.spawn.waveKillsGoal);
    },

    spawnEnemyInstance: function(typeId, x, y, key = null) {
        var st = BJZ.state; var cfg = BJZ.cfg;
        if (key === null) {
            key = this.enemyKeyPool.find(k => !this.enemyRects[k] || !this.enemyRects[k].body || !this.enemyRects[k].body.enable);
        }
        if (!key) return null;

        var t = cfg.enemies.types[typeId];
        var w = (typeId === "TANK" ? 48 : 40);
        var h = (typeId === "TANK" ? 70 : 60);

        var wv = st.spawn.wave;
        var scale = cfg.spawning.scalePerWave;
        var hpMax = Math.round(t.hpMax * Math.pow(scale.hpMul, wv - 1));
        var dmg = Math.round(t.touchDamage * Math.pow(scale.dmgMul, wv - 1));
        var spdMul = Math.pow(scale.speedMul, wv - 1);

        var rect = this.enemyRects[key];
        if (!rect) {
            rect = this.add.rectangle(x, y, w, h, t.color);
            this.physics.add.existing(rect, false);
            this.enemyRects[key] = rect;
            this.enemyHpTexts[key] = this.add.text(0, 0, '', { fontFamily: 'monospace', fontSize: '10px', color: '#ffffff' }).setOrigin(0.5);
            rect.setData('key', key); // BUGFIX 8G.1
            this.enemyGroup.add(rect); 
            st.spawn.aliveCount++; // NEW ACTIVATION
            st.debug.aliveGuardOk = 1;
        } else {
            // BUGFIX 8G.1/2: Unified transition guard
            if (!rect.body.enable) {
                st.spawn.aliveCount++;
                st.debug.aliveGuardOk = 1;
            } else {
                st.debug.aliveGuardOk = 0;
            }
            rect.setPosition(x, y).setSize(w, h).fillColor = t.color;
            rect.setVisible(true);
            rect.body.setEnable(true).setSize(w, h).setVelocity(0, 0);
            if (!this.enemyGroup.contains(rect)) this.enemyGroup.add(rect);
        }
        rect.body.setAllowGravity(false).setCollideWorldBounds(true).setDrag(400, 400);

        st.enemies[key] = {
            // ... (keep same st.enemies[key] object)
            typeId: typeId, label: t.label,
            hpMax: hpMax, hp: hpMax, invulnMs: 0,
            aiState: "idle", touchCdMs: 0,
            atkState: "ready", atkTimerMs: 0,
            readyLockMs: 250, inRange: 0,
            moveSpeedX: t.moveSpeedX * spdMul,
            moveSpeedY: t.moveSpeedY * spdMul,
            stopDistX: t.stopDistX,
            windupMs: t.windupMs, hitWindowMs: t.hitWindowMs,
            touchDamage: dmg, touchCooldownMs: t.touchCooldownMs,
            knockbackPxOnA2: t.knockbackPxOnA2
        };
        console.log("ALIVE_GUARD_OK:", st.debug.aliveGuardOk, "aliveCount:", st.spawn.aliveCount);
        console.log("SPAWN", key, typeId, "aliveCount", st.spawn.aliveCount);
        return key;
    },

    triggerHitFeedback: function(type, x, y) {
        var st = BJZ.state; var cfg = BJZ.cfg;
        if (!cfg.juice.enabled) return;

        if (cfg.juice.hitstop.enabled) {
            var hitstopDur = cfg.juice.hitstop[type + "Ms"] || 0;
            st.hitstopMs = Math.min(cfg.juice.hitstop.maxMs, hitstopDur);
            st.hitstopReason = type;
            st.debug.hitstopCount++;
        }

        if (cfg.juice.shake.enabled) {
            var s = cfg.juice.shake[type];
            if (s) this.cameras.main.shake(s.dur, s.inten);
        }

        if (cfg.juice.impactPulse.enabled) {
            var p = this.add.circle(x, y, 18, 0xffffff, cfg.juice.impactPulse.alphaFrom);
            p.setDepth(50);
            this.tweens.add({
                targets: p, radius: 34, alpha: cfg.juice.impactPulse.alphaTo,
                duration: cfg.juice.impactPulse.durMs,
                onComplete: () => { if (p && p.scene) p.destroy(); }
            });
        }
    },

    enqueueSpawn: function(typeId, atMs) {
        BJZ.state.spawn.queued.push({ typeId: typeId, atMs: atMs });
    },

    // PROMPT 8G: Wave Initialization
    initWave: function(waveNum) {
        var st = BJZ.state; var cfg = BJZ.cfg;
        var w = cfg.spawning.wave;
        st.spawn.wave = waveNum;
        st.spawn.waveBudget = w.baseBudget + (waveNum - 1) * w.budgetPerWave;
        st.spawn.waveRemainingBudget = st.spawn.waveBudget;
        st.spawn.waveKillsGoal = w.baseKillsGoal + (waveNum - 1) * w.killsPerWave;
        st.spawn.killsThisWave = 0;
        st.spawn.wavePhase = "build";
        st.spawn.lastWaveStartMs = this.time.now;
        st.debug.spawnLog = "WAVE " + waveNum + " START (Build)";
    },

    trySpawn: function(time) {
        var st = BJZ.state; var cfg = BJZ.cfg;
        if (!cfg.spawning.enabled || st.playerHP <= 0) return;
        
        // Phase Logic
        if (st.spawn.wavePhase === "breather") {
            if (time >= st.spawn.waveTimerMs) {
                this.initWave(st.spawn.wave + 1);
                console.log("WAVE_START:", st.spawn.wave, "budget:", st.spawn.waveBudget);
            }
            return;
        }

        if (st.spawn.wavePhase === "clear") {
            if (st.spawn.aliveCount === 0) {
                st.spawn.wavePhase = "breather";
                var w = cfg.spawning.wave;
                var dur = Phaser.Math.Between(w.breatherMsMin, w.breatherMsMax);
                st.spawn.waveTimerMs = time + dur;
                st.debug.spawnLog = "WAVE " + st.spawn.wave + " CLEARED. Breather " + dur + "ms";
                console.log("WAVE_END:", st.spawn.wave, "dur:", time - st.spawn.lastWaveStartMs);
            }
            return;
        }

        // Phase build logic
        if (st.spawn.wavePhase === "build" && (st.spawn.waveRemainingBudget <= 0 || st.spawn.killsThisWave >= st.spawn.waveKillsGoal)) {
            st.spawn.wavePhase = "clear";
            st.debug.spawnLog = "WAVE " + st.spawn.wave + " GOAL REACHED (Clear)";
            return;
        }

        // Fairness / Timing guards
        if (time < st.spawn.noSpawnUntilMs) return;
        if (time < st.spawn.lastSpawnTime + (cfg.spawning.tickMs || 450)) return;
        if (st.spawn.aliveCount >= cfg.spawning.maxAlive) return;

        // Weighted Selection according to budget
        var r = Math.random();
        var typeId = "GRUNT";
        if (r < cfg.spawning.typeWeights.TANK) typeId = "TANK";
        
        var cost = cfg.enemies.types[typeId].cost;
        if (st.spawn.waveRemainingBudget < cost) {
            typeId = "GRUNT"; // Fallback to grunt if cant afford tank
            if (st.spawn.waveRemainingBudget < 1) return; // Cant even afford grunt
        }

        // Ring Placement & Selection (12 tries)
        var bestX = 0, bestY = 0, bestScore = -1;
        var minDistP = cfg.spawning.minDistFromPlayer;
        var minDistE = cfg.spawning.minDistFromOtherEnemy;
        
        for (var i = 0; i < 12; i++) {
            var ang = Math.random() * Math.PI * 2;
            var dist = Phaser.Math.Between(cfg.spawning.rMin, cfg.spawning.rMax);
            var tx = Phaser.Math.Clamp(this.playerRect.x + Math.cos(ang) * dist, 50, cfg.worldWidth - 50);
            var ty = Phaser.Math.Clamp(this.playerRect.y + Math.sin(ang) * dist, cfg.laneTop, cfg.laneBottom);
            
            var dp = Phaser.Math.Distance.Between(this.playerRect.x, this.playerRect.y, tx, ty);
            if (dp < minDistP) continue;

            var de = 9999;
            this.forEachAliveEnemy((key, rect) => {
                var d = Phaser.Math.Distance.Between(tx, ty, rect.x, rect.y);
                if (d < de) de = d;
            });

            var score = dp + (de > minDistE ? 500 : de); // Favor distant from player and far from others
            if (score > bestScore) {
                bestScore = score; bestX = tx; bestY = ty;
            }
        }

        if (bestScore !== -1) {
            var key = this.spawnEnemyInstance(typeId, bestX, bestY);
            if (key) {
                st.spawn.lastSpawnTime = time;
                st.spawn.waveRemainingBudget -= cfg.enemies.types[typeId].cost;
                st.debug.spawnLog = "SPAWN " + key + " (" + typeId + ") c=" + cfg.enemies.types[typeId].cost + " wB=" + st.spawn.waveRemainingBudget;
                st.debug.lastSpawnPickReason = "score:" + Math.round(bestScore);
            }
        }
        st.debug.lastSpawnTryCount = 12;
    },
    
    // PROMPT 7B/7C: Enemy Touch Hit Trigger
    tryEnemyTouchHit: function(key, rect) {
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (!rect.body || !rect.body.enable || en.hp <= 0 || st.playerHP <= 0) return;
        if (st.playerInvulnMs > 0 || en.touchCdMs > 0 || en.readyLockMs > 0 || en.atkState !== "ready") return;
        
        // Check Range
        var dx = Math.abs(this.playerRect.x - rect.x);
        var dy = Math.abs(this.playerRect.y - rect.y);
        var inRange = (dx <= en.stopDistX + 6) && (dy <= 26);
        if (!inRange) return;

        // ENTER WINDUP
        en.atkState = "windup";
        en.atkTimerMs = en.windupMs;
        this.setEnemyVisual(key, rect);
        st.debug.attackTrace = key.toUpperCase() + " WINDUP (" + en.typeId + ")";
        
        // VFX
        var msg = this.add.text(rect.x, rect.y - 70, '!', {
             fontFamily: 'monospace', fontSize: '24px', color: '#ffcc00', fontStyle: 'bold', stroke: '#000', strokeThickness: 3
        }).setOrigin(0.5);
        this.tweens.add({ targets: msg, scale: 1.4, y: rect.y - 100, duration: en.windupMs, onComplete: () => { if(msg.scene) msg.destroy(); } });
        this.tweens.add({ targets: rect, scale: 1.08, duration: en.windupMs / 2, yoyo: true });
    },

    setEnemyVisual: function(key, rect) {
        var cfg = BJZ.cfg; var en = BJZ.state.enemies[key];
        if (!en) return;
        if (en.atkState === "window") rect.fillColor = 0xff3333;
        else if (en.atkState === "windup") rect.fillColor = cfg.colors.enemyWindup;
        else rect.fillColor = cfg.enemies.types[en.typeId].color;
    },

    // PROMPT 7A: Apply actual damage logic (called from FSM)
    applyPlayerHit: function(senderKey, senderRect) {
        var st = BJZ.state;
        var cfg = BJZ.cfg;
        var en = st.enemies[senderKey];
        
        st.playerHP = Math.max(0, st.playerHP - en.touchDamage);
        st.playerHitCount++;
        st.lastPlayerHitBy = senderKey;
        st.playerInvulnMs = cfg.playerHitInvulnMs;
        st.debug.lastPlayerHitTime = this.time.now;
        
        // PROMPT 8A: Feedback
        this.triggerHitFeedback("playerHit", this.playerRect.x, this.playerRect.y);

        // KNOCKBACK
        st.playerKnockMs = cfg.playerKnockbackMs;
        st.playerKnockVx = (this.playerRect.x < senderRect.x ? -cfg.playerKnockbackSpeed : cfg.playerKnockbackSpeed);

        // PROMPT 8G: Breather on hit
        st.spawn.noSpawnUntilMs = this.time.now + cfg.spawning.breatherAfterHitMs;

        st.lastAction = "PLAYER HIT by " + senderKey + " (" + en.typeId + ")";
        if (st.playerHP === 0 && st.playerAlive) {
            st.playerAlive = false;
            st.playerDownTimeMs = 0;
            st.lastAction = "PLAYER DOWN";
            this.playerRect.body.setVelocity(0, 0);
            this.playerRect.alpha = cfg.playerDownAlpha;
        }
        
        this.cameras.main.shake(90, 0.003);
        this.playerRect.alpha = 0.5;
        this.time.delayedCall(120, () => { if(this.playerRect && this.playerRect.scene) this.playerRect.alpha = 1.0; });
        
        var dmgTxt = this.add.text(this.playerRect.x, this.playerRect.y - 50, '-' + en.touchDamage, {
             fontFamily: 'monospace', fontSize: '18px', color: '#ff0000', fontStyle: 'bold', stroke: '#fff', strokeThickness: 2
        }).setOrigin(0.5);
        this.tweens.add({ targets: dmgTxt, y: this.playerRect.y - 110, alpha: 0, duration: 750, onComplete: () => { if(dmgTxt.scene) dmgTxt.destroy(); } });
    },

    // A1 Logic
    fireA1: function() {
        var cfg = BJZ.cfg;
        var hx = this.playerRect.x + this.playerFacing * cfg.a1.hitboxX;
        var hy = this.playerRect.y + cfg.a1.hitboxY;
        this.a1Hitbox.setPosition(hx, hy).body.setEnable(true);
        this._a1HitThisFire = {}; // PROMPT 8E: Dynamic map
        BJZ.state.debug.a1MapSize = 0;
        this.time.delayedCall(cfg.a1.duration, () => { if(this.a1Hitbox.scene) { this.a1Hitbox.body.setEnable(false); this.a1Hitbox.setPosition(-1000, -1000); } });
    },
    
    // A2 Logic
    fireA2: function() {
        var cfg = BJZ.cfg;
        var hx = this.playerRect.x + this.playerFacing * cfg.a2.hitboxX;
        var hy = this.playerRect.y + cfg.a2.hitboxY;
        this.a2Hitbox.setPosition(hx, hy).body.setEnable(true);
        this._a2HitThisFire = {}; // PROMPT 8E: Dynamic map
        BJZ.state.debug.a2MapSize = 0;
        this.time.delayedCall(cfg.a2.duration, () => { if(this.a2Hitbox.scene) { this.a2Hitbox.body.setEnable(false); this.a2Hitbox.setPosition(-1000, -1000); } });
    },
    
    // SUPER Logic
    fireSuper: function() {
        var cfg = BJZ.cfg;
        var px = this.playerRect.x; var py = this.playerRect.y;
        this.cameras.main.shake(120, 0.004);
        var flash = this.add.rectangle(cfg.gameWidth/2, cfg.gameHeight/2, cfg.gameWidth, cfg.gameHeight, 0xffffff, cfg.ui.flashAlpha).setScrollFactor(0).setDepth(9999);
        this.tweens.add({ targets: flash, alpha: 0, duration: cfg.ui.flashDuration, onComplete: () => { if(flash.scene) flash.destroy(); } });
        var gfx = this.add.graphics(); gfx.lineStyle(2, 0xffff00, 0.6); gfx.strokeCircle(px, py, cfg.super.radius);
        this.time.delayedCall(250, () => { if(gfx.scene) gfx.destroy(); });
        BJZ.state.debug.lastSuperHits = {}; // PROMPT 8E: Dynamic map
        Object.keys(this.enemyRects).forEach(key => {
            this.checkSuperHit(key, this.enemyRects[key]);
        });
    },
    
    checkSuperHit: function(key, rect) {
        if (!rect.body || !rect.body.enable) return;
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (en.invulnMs > 0) return;
        if (Phaser.Math.Distance.Between(this.playerRect.x, this.playerRect.y, rect.x, rect.y) <= cfg.super.radius) {
            st.debug.lastSuperHits[key] = 1;
            this.damageEnemy(key, rect, cfg.super.damage, '#f40', cfg.super.invulnMs);
            this.triggerHitFeedback("super", rect.x, rect.y);
            console.log("HIT_SUPER", key, "hp", en.hp);
        }
    },
    
    handleA2Hit: function(key, rect) {
        if (!rect.body || !rect.body.enable) return;
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (this._a2HitThisFire[key] || en.invulnMs > 0) return; 
        this._a2HitThisFire[key] = true;
        st.debug.a2MapSize++;
        this.damageEnemy(key, rect, cfg.a2.damage, '#f80', cfg.a2.invulnMs);
        this.triggerHitFeedback("a2", rect.x, rect.y);
        console.log("HIT_A2", key, "hp", en.hp);
        rect.x += this.playerFacing * en.knockbackPxOnA2; rect.x = Phaser.Math.Clamp(rect.x, 20, cfg.worldWidth - 20);
    },
    
    applyDamageToEnemy: function(key, rect) {
        var cfg = BJZ.cfg;
        this.damageEnemy(key, rect, cfg.a1.damage, '#ff0', 0);
        this.triggerHitFeedback("a1", rect.x, rect.y);
        console.log("HIT_A1", key, "hp", BJZ.state.enemies[key].hp);
        BJZ.state.debug.collisions.a1Hit = 1; 
    },

    damageEnemy: function(key, rect, amount, txtColor, invulnMs = 0) {
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (en.hp <= 0 || en.invulnMs > 0) return;
        
        en.hp = Math.max(0, en.hp - amount);
        if (invulnMs > 0) en.invulnMs = invulnMs;

        var dmgTxt = this.add.text(rect.x, rect.y-50, '-'+amount, {
            fontFamily:'monospace', fontSize:'16px', color:txtColor, fontStyle:'bold', stroke:'#fff', strokeThickness:2
        }).setOrigin(0.5);
        this.tweens.add({targets:dmgTxt, y:rect.y-110, alpha:0, duration:600, onComplete:()=>{ if(dmgTxt.scene) dmgTxt.destroy(); }});
        
        rect.alpha = 0.5;
        this.time.delayedCall(120, () => { if (this.isAliveRect(rect)) rect.alpha = 1.0; });
        
        if (en.hp <= 0) {
            en.hp = 0; rect.setVisible(false); if(rect.body) rect.body.setEnable(false);
            
            // PROMPT 8D: Incremental aliveCount
            st.spawn.aliveCount = Math.max(0, st.spawn.aliveCount - 1);

            // PROMPT 8G: Kill tracking
            st.spawn.killsThisWave++;
            st.spawn.totalKills++;
            st.score += cfg.spawning.scorePerKill;
            
            st.debug.spawnLog = "KILL " + key + " (" + en.typeId + ") wK=" + st.spawn.killsThisWave + "/" + st.spawn.waveKillsGoal;

            st.lastAction = "ENEMY " + key + " KILLED";
            st.debug.attackTrace = key.toUpperCase() + " KILLED";
        }
    },

    onPlayerEnemy: function() {
        var f = this.game.loop.frame;
        if (f !== this._collFrameEnemy) { BJZ.state.debug.collisions.playerEnemy++; this._collFrameEnemy = f; }
    },
    onPlayerObstacle: function() {
        var f = this.game.loop.frame;
        if (f !== this._collFrameObstacle) { BJZ.state.debug.collisions.playerObstacle++; this._collFrameObstacle = f; }
    },

    gameTick: function () {
        var st = BJZ.state;
        st.timeSeconds += 1;
        
        // PROMPT 7D: Repaired GameTick (Removed debug HP auto-drain)
        if (this.bossDeadPendingReset) { st.bossHP = st.bossHPMax; this.bossDeadPendingReset = false; }
        if (this.playerDeadPendingReset) { st.playerHP = st.playerHPMax; this.playerDeadPendingReset = false; }
        
        st.super = Math.min(Math.max(st.super + BJZ.cfg.super.chargeRate, 0), BJZ.cfg.super.max);
        st.superReady = (st.super >= BJZ.cfg.super.max);
    },

    updateEnemyAI: function(key, rect) {
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (!rect.body || !rect.body.enable || en.hp <= 0) return;
        
        var dx = this.playerRect.x - rect.x; var dy = this.playerRect.y - rect.y;
        var absDx = Math.abs(dx); var absDy = Math.abs(dy);
        
        // RANGE TRACKING
        var inRange = (absDx <= en.stopDistX + 10) && (absDy <= 30);
        en.inRange = inRange ? 1 : 0;
        if (key === 'e1') st.debug.inRangeE1 = en.inRange; else st.debug.inRangeE2 = en.inRange;

        // PROMPT 7B/7C: Attack Logic Trigger
        if (en.atkState === "ready") {
            this.tryEnemyTouchHit(key, rect);
        }

        // MOVEMENT
        if (en.atkState !== "ready") {
            rect.body.setVelocity(0, 0); // No micro-step back anymore, use commit-step if needed
            return;
        }

        if (en.aiState === "idle") { if (absDx > en.stopDistX) en.aiState = "chase"; } 
        else if (en.aiState === "stop") { if (absDx > en.stopDistX + 10) en.aiState = "chase"; rect.body.setVelocity(0, 0); }
        else if (en.aiState === "chase") {
            var vx = 0; var vy = 0;
            if (dx > en.stopDistX) vx = en.moveSpeedX; else if (dx < -en.stopDistX) vx = -en.moveSpeedX;
            if (absDy > cfg.ai.laneSnapDistY) vy = (dy > 0 ? 1 : -1) * en.moveSpeedY;
            rect.body.setVelocity(vx, vy);
            if (absDx <= en.stopDistX) { en.aiState = "stop"; rect.body.setVelocity(0, 0); }
        }
        st.debug.ai[key] = en.aiState;
    },

    // PROMPT 7B: FSM Advancement
    processEnemyAttackFSM: function(key, rect, delta) {
        var st = BJZ.state; var cfg = BJZ.cfg; var en = st.enemies[key];
        if (!rect.body || !rect.body.enable || en.hp <= 0) return;

        // Recovery Lock handling
        if (en.readyLockMs > 0) en.readyLockMs = Math.max(0, en.readyLockMs - delta);

        if (en.atkState !== "ready") {
            en.atkTimerMs = Math.max(0, en.atkTimerMs - delta);
            
            // TRANSITION: Windup -> Window
            if (en.atkState === "windup" && en.atkTimerMs === 0) {
                en.atkState = "window";
                en.atkTimerMs = en.hitWindowMs;
                this.setEnemyVisual(key, rect);
                st.debug.attackTrace = key.toUpperCase() + " WINDOW (" + en.typeId + ")";
            }
            
            // STATE: Window (Check for Hit)
            if (en.atkState === "window") {
                var absDx = Math.abs(this.playerRect.x - rect.x);
                var absDy = Math.abs(this.playerRect.y - rect.y);
                var inRange = (absDx <= en.stopDistX + 8) && (absDy <= 28);
                
                if (inRange && st.playerHP > 0 && st.playerInvulnMs <= 0 && en.touchCdMs <= 0) {
                    this.applyPlayerHit(key, rect);
                    en.touchCdMs = en.touchCooldownMs;
                    en.atkState = "ready"; en.readyLockMs = 150;
                    this.setEnemyVisual(key, rect);
                    st.debug.attackTrace = key.toUpperCase() + " HIT";
                } else if (en.atkTimerMs === 0) {
                    // Window expired without hit = DODGE
                    en.atkState = "ready"; en.touchCdMs = 350; en.readyLockMs = 150;
                    this.setEnemyVisual(key, rect);
                    if (!inRange) {
                        st.debug.dodges++;
                        st.debug.attackTrace = key.toUpperCase() + " DODGE";
                    } else {
                        st.debug.attackTrace = key.toUpperCase() + " BLOCKED (invuln)";
                    }
                }
            }
        }
    },

    update: function (time, delta) {
        var st = BJZ.state; var inp = BJZ.input; var cfg = BJZ.cfg;

        // PROMPT 8D: Motion-only Hitstop (Timers advance, movement freezes)
        var isHitstop = (cfg.juice.enabled && cfg.juice.hitstop.enabled && st.hitstopMs > 0);
        if (isHitstop) {
            st.hitstopMs = Math.max(0, st.hitstopMs - delta);
        }

        var k = this.keys; var kb = inp.kb;
        kb.left = k.left.isDown || k.a.isDown; kb.right = k.right.isDown || k.d.isDown;
        kb.up = k.up.isDown || k.w.isDown; kb.down = k.down.isDown || k.s.isDown;
        kb.attack1 = k.j.isDown; kb.attack2 = k.k.isDown; kb.super = k.l.isDown;
        var touch = inp.touch; inp.attack1 = touch.attack1 || kb.attack1; inp.attack2 = touch.attack2 || kb.attack2; inp.super = touch.super || kb.super;
        inp.a1Pressed = inp.attack1 && !inp.a1WasDown; inp.a1WasDown = inp.attack1;
        inp.a2Pressed = inp.attack2 && !inp.a2WasDown; inp.a2WasDown = inp.attack2;
        inp.supPressed = inp.super && !inp.supWasDown; inp.supWasDown = inp.super;
        if (inp.a1Pressed) inp.lastA1PressTime = time; if (inp.a2Pressed) inp.lastA2PressTime = time;
        
        // --- PLAYER DEATH/RESPAWN LOGIC ---
        if (!st.playerAlive) {
            st.playerDownTimeMs += delta;
            this.playerRect.body.setVelocity(0, 0);
            inp.moving = false; inp.moveX = 0; inp.moveY = 0; inp.moveMag = 0;
            inp.attack1 = false; inp.attack2 = false; inp.super = false;
            inp.a1Pressed = false; inp.a2Pressed = false; inp.supPressed = false;

            if (st.playerDownTimeMs >= cfg.playerRespawnMs) {
                st.playerHP = st.playerHPMax;
                st.playerAlive = true;
                st.playerDownTimeMs = 0;
                this.playerRect.alpha = 1.0;
                st.lastAction = "PLAYER RESPAWN";
            }
        }

        // Timers
        st.playerInvulnMs = Math.max(0, st.playerInvulnMs-delta);
        st.playerKnockMs = Math.max(0, st.playerKnockMs-delta);
        st.cooldownMs.a1 = Math.max(0, st.cooldownMs.a1-delta);
        st.cooldownMs.a2 = Math.max(0, st.cooldownMs.a2-delta);
        st.cooldownMs.super = Math.max(0, st.cooldownMs.super-delta);
        
        this.forEachAliveEnemy((key, rect, en) => {
            en.touchCdMs = Math.max(0, en.touchCdMs - delta);
            en.invulnMs = Math.max(0, en.invulnMs - delta);
            en.readyLockMs = Math.max(0, en.readyLockMs - delta);
            
            if (!isHitstop) {
                this.processEnemyAttackFSM(key, rect, delta);
                this.updateEnemyAI(key, rect);
            } else if (rect.body) {
                rect.body.setVelocity(0, 0);
            }
        });
        
        // Combat
        if (!isHitstop) {
            if (inp.a1Pressed && st.cooldownMs.a1 <= 0) {
                st.debug.a1Latency = time - inp.lastA1PressTime; st.cooldownMs.a1 = cfg.a1.cooldownMs; st.score += 1; st.stats.a1Fires++; st.lastAction = "A1 fired"; this.fireA1();
            }
            if (inp.a2Pressed && st.cooldownMs.a2 <= 0) {
                st.debug.a2Latency = time - inp.lastA2PressTime; st.cooldownMs.a2 = cfg.a2.cooldownMs; st.score += 2; st.stats.a2Fires++; st.lastAction = "A2 fired"; this.fireA2();
            }
            if (inp.supPressed && st.superReady && st.cooldownMs.super <= 0) {
                st.cooldownMs.super = cfg.super.cooldownMs; st.stats.superFires++; st.lastAction = "SUPER fired"; st.super = 0; this.fireSuper();
            }
        }

        // Movement
        if (inp.joyPointerId === null) {
            var kx = (kb.right?1:0)-(kb.left?1:0); var ky = (kb.down?1:0)-(kb.up?1:0);
            if(kx||ky) { inp.moveX=kx; inp.moveY=ky; inp.moveMag=1; inp.moving=true; } else { inp.moveX=0; inp.moveY=0; inp.moveMag=0; inp.moving=false; }
        }
        var body = this.playerRect.body; var vx = 0; var vy = 0;
        
        if (st.playerKnockMs > 0) {
            vx = st.playerKnockVx;
            vy = (inp.moving ? inp.moveY * cfg.playerSpeedY : 0);
        } else if (inp.moving) {
            vx = inp.moveX * cfg.playerSpeedX; vy = inp.moveY * cfg.playerSpeedY;
            if (inp.moveX > 0.15) this.playerFacing = 1; else if (inp.moveX < -0.15) this.playerFacing = -1;
        }

        if (isHitstop) {
            body.setVelocity(0, 0);
        } else {
            body.setVelocity(vx, vy);
        }

        if (this.playerRect.y < cfg.laneTop) { this.playerRect.y = cfg.laneTop; if (body.velocity.y < 0 && !isHitstop) body.setVelocityY(0); } 
        else if (this.playerRect.y > cfg.laneBottom) { this.playerRect.y = cfg.laneBottom; if (body.velocity.y > 0 && !isHitstop) body.setVelocityY(0); }
        
        this.facingText.setPosition(this.playerRect.x, this.playerRect.y).setText(this.playerFacing === 1 ? ">" : "<");
        this.playerLabel.setPosition(this.playerRect.x, this.playerRect.y-45).setText("PLAYER "+Math.round(this.playerRect.x)+","+Math.round(this.playerRect.y));
        this.pHpText.setPosition(this.playerRect.x, this.playerRect.y - 40).setText("HP: " + st.playerHP + "/" + st.playerHPMax);
        
        this.enemyKeyPool.forEach(k => {
            var en = st.enemies[k]; var rect = this.enemyRects[k]; var txt = this.enemyHpTexts[k];
            if (en && en.hp > 0 && rect) {
                txt.setPosition(rect.x, rect.y - 45).setText(en.typeId + " " + en.hp + "/" + en.hpMax).setVisible(true);
            } else if (txt) {
                txt.setVisible(false);
            }
        });

        st.debug.playerX = Math.round(this.playerRect.x); st.debug.playerY = Math.round(this.playerRect.y);
        st.debug.vx = Math.round(body.velocity.x); st.debug.vy = Math.round(body.velocity.y); st.debug.facing = this.playerFacing;

        // PROMPT 8H: Parallax Scroll Update
        var camX = this.cameras.main.scrollX;
        st.debug.camX = camX; // Save for HUD
        var pCfg = cfg.spawning.parallax.speeds;
        if (this.farTS) this.farTS.tilePositionX = camX * pCfg.far;
        if (this.midTS) this.midTS.tilePositionX = camX * pCfg.mid;
        if (this.nearTS) this.nearTS.tilePositionX = camX * pCfg.near;

        this.trySpawn(time);
    }
});

// ============================================================
//  HUD SCENE
// ============================================================
var HudScene = new Phaser.Class({
    Extends: Phaser.Scene,
    initialize: function HudScene() { 
        Phaser.Scene.call(this, { key: 'HudScene' }); 
        this.buttonStates = {'A1':null,'A2':null,'SUP':null}; 
        this.debugClicks = {'A1':0,'A2':0,'SUP':0}; 
        this._touchButtons = []; 
        this._hudPointers = { joyId: null };
        this._dbgAccMs = 0;
        this._dbgLastText = "";
        this._showDebug = true; // PROMPT 8: Toggle visibility
    },
    create: function () {
        var cfg = BJZ.cfg; var st = BJZ.state; var inp = BJZ.input;
        var joyX = 100, joyY = 360, joyOuterR = 52, joyInnerR = 18;
        this.panelGfx = this.add.graphics(); this.panelGfx.fillStyle(0x0, 0.65); this.panelGfx.fillRect(0, 0, cfg.gameWidth, 52); this.panelGfx.fillStyle(0x0, 0.55); this.panelGfx.fillRect(0, cfg.gameHeight-20, cfg.gameWidth, 20);
        this.panelGfx.setDepth(0).setScrollFactor(0);

        this.add.text(10, 6, 'HP', {fontFamily:'monospace',fontSize:'11px',color:'#f66',fontStyle:'bold'}).setDepth(20).setScrollFactor(0);
        this.add.text(10, 20, 'SP', {fontFamily:'monospace',fontSize:'11px',color:'#fc3',fontStyle:'bold'}).setDepth(20).setScrollFactor(0);
        this.scoreText = this.add.text(200, 6, 'SCORE 0', {fontFamily:'monospace',fontSize:'14px',color:'#fff',fontStyle:'bold'}).setDepth(20).setScrollFactor(0);
        this.timeText = this.add.text(200, 24, 'TIME 00:00', {fontFamily:'monospace',fontSize:'12px',color:'#aaa'}).setDepth(20).setScrollFactor(0);
        this.bossInfoText = this.add.text(560, 20, 'BOSS HP: 1000/1000', {fontFamily:'monospace',fontSize:'10px',color:'#c66'}).setDepth(20).setScrollFactor(0);
        this.debugOverlayText = this.add.text(10, 310, 'Init...', {fontFamily:'monospace',fontSize:'10px',color:'#ff0',backgroundColor:'#000a'}).setDepth(30).setScrollFactor(0);
        this.barsGfx = this.add.graphics();
        this.barsGfx.setDepth(10).setScrollFactor(0);
        
        this.joyBaseGfx = this.add.graphics().setScrollFactor(0); 
        this.joyBaseGfx.fillStyle(0xfff, 0.08); this.joyBaseGfx.fillCircle(joyX, joyY, joyOuterR);
        this.joyThumb = this.add.graphics().setScrollFactor(0); 
        this.joyThumb.fillStyle(0xfff, 0.3); this.joyThumb.fillCircle(0, 0, joyInnerR).setPosition(joyX, joyY);
        
        this.btnA1 = this.createButton(660, 380, 22, 'A1', 'attack1', {fill:0x36c,label:'#8bf'});
        this.btnA2 = this.createButton(720, 360, 22, 'A2', 'attack2', {fill:0x3a5,label:'#8fa'});
        this.btnSuper = this.createButton(690, 330, 28, 'SUP', 'super', {fill:0xc80,label:'#fc4'});
        this._touchButtons = [this.btnA1, this.btnA2, this.btnSuper];

        // --- TOGGLE DEBUG ---
        this.input.keyboard.on('keydown-O', () => {
            this._showDebug = !this._showDebug;
            this.debugOverlayText.setVisible(this._showDebug);
            console.log("DEBUG OVERLAY TOGGLE:", this._showDebug);
        });

        // --- CONSOLIDATED INPUT ROUTING ---
        var updateJoy = (p) => {
            var dx=p.x-joyX; var dy=p.y-joyY; var dist=Math.sqrt(dx*dx+dy*dy);
            if(dist<6){ inp.moveX=0;inp.moveY=0;inp.moveMag=0;inp.moving=false;this.joyThumb.setPosition(joyX,joyY);return; }
            var lim=Math.min(dist,joyOuterR-2); var ang=Math.atan2(dy,dx);
            var tx=joyX+Math.cos(ang)*lim; var ty=joyY+Math.sin(ang)*lim;
            this.joyThumb.setPosition(tx,ty); inp.moveX=(tx-joyX)/(joyOuterR-2); inp.moveY=(ty-joyY)/(joyOuterR-2); inp.moveMag=lim/(joyOuterR-2); inp.moving=true;
        };

        var joyZone = this.add.zone(joyX, joyY, joyOuterR*2, joyOuterR*2).setInteractive(new Phaser.Geom.Circle(0,0,joyOuterR), Phaser.Geom.Circle.Contains).setScrollFactor(0);
        joyZone.on('pointerdown', (p) => {
            if (this._hudPointers.joyId !== null) return;
            var usedByBtn = this._touchButtons.some(b => b.pointerId === p.id);
            if (usedByBtn) return;
            this._hudPointers.joyId = p.id;
            updateJoy(p);
        });

        this.input.on('pointermove', (p) => {
            if (this._hudPointers.joyId === p.id && p.isDown) {
                updateJoy(p);
            }
            this._touchButtons.forEach(btn => {
                if (btn.pointerId === p.id && p.isDown) {
                    var dist = Phaser.Math.Distance.Between(p.x, p.y, btn.x, btn.y);
                    if (dist > btn.r) {
                        btn.pointerId = null;
                        BJZ.input.touch[btn.key] = false;
                        btn.drawFn(false, (btn.key === 'super' ? BJZ.state.superReady : true));
                        BJZ.state.lastInputEvent = btn.label + " cancel id=" + p.id;
                    }
                }
            });
        });

        this.input.on('pointerup', (p) => {
            if (this._hudPointers.joyId === p.id) {
                this._hudPointers.joyId = null;
                inp.moveX=0; inp.moveY=0; inp.moveMag=0; inp.moving=false; this.joyThumb.setPosition(joyX,joyY);
            }
            this._touchButtons.forEach(btn => {
                if (btn.pointerId === p.id) {
                    btn.pointerId = null;
                    BJZ.input.touch[btn.key] = false;
                    btn.drawFn(false, (btn.key === 'super' ? BJZ.state.superReady : true));
                    BJZ.state.lastInputEvent = btn.label + " up id=" + p.id;
                }
            });
        });

        console.log("HUD ROUTING OK");
        console.log("HUD DEBUG RATE LIMITED (10Hz)");
    },
    createButton: function(x, y, r, label, key, colors) {
        var zone = this.add.zone(x, y, r*2, r*2).setInteractive(new Phaser.Geom.Circle(0,0,r), Phaser.Geom.Circle.Contains).setScrollFactor(0);
        var gfx = this.add.graphics().setScrollFactor(0); 
        var txt = this.add.text(x, y, label, {fontFamily:'monospace',fontSize:'11px',color:colors.label,fontStyle:'bold'}).setOrigin(0.5).setScrollFactor(0).setDepth(20);

        var draw = (isPressed, isEnabled = true) => {
            gfx.clear(); 
            var alpha = isEnabled ? 0.35 : 0.1; 
            gfx.fillStyle(isEnabled ? (isPressed ? 0x666666 : colors.fill) : 0x444, alpha); 
            gfx.fillCircle(x,y,r);
            gfx.lineStyle(2, isEnabled ? 0x888 : 0x444, 0.5); 
            gfx.strokeCircle(x,y,r); 
            txt.setColor(isEnabled ? colors.label : '#666');
            if (isPressed) txt.setScale(0.95); else txt.setScale(1);
        };
        draw(false); 

        var btnObj = { key:key, label:label, x:x, y:y, r:r, zone:zone, drawFn:draw, pointerId:null };

        zone.on('pointerdown', (p) => { 
            if (btnObj.pointerId !== null) return;
            if (this._hudPointers.joyId === p.id) return;
            var enabled = (key === 'super') ? BJZ.state.superReady : true;
            if (!enabled) {
                BJZ.state.lastInputEvent = label + " locked";
                return;
            }
            btnObj.pointerId = p.id;
            BJZ.input.touch[key] = true; 
            draw(true, true); 
            BJZ.state.lastInputEvent = label + " down id=" + p.id;
        });

        return btnObj;
    },
    update: function(time, delta) {
        var st = BJZ.state; var inp = BJZ.input; var e = st.enemies; var cfg = BJZ.cfg;
        this.btnA1.drawFn(inp.touch.attack1, true);
        this.btnA2.drawFn(inp.touch.attack2, true);
        this.btnSuper.drawFn(inp.touch.super, st.superReady);
        this.scoreText.setText('SCORE ' + st.score); this.timeText.setText('TIME ' + Math.floor(st.timeSeconds/60)+':'+(st.timeSeconds%60 < 10 ? '0':'')+(st.timeSeconds%60));
        this.bossInfoText.setText('BOSS HP: ' + st.bossHP + '/' + st.bossHPMax);

        var getPct = (cur, max) => {
            var p = (max > 0) ? (cur / max) : 0;
            return Phaser.Math.Clamp(isFinite(p) ? p : 0, 0, 1);
        };
        var hPct = getPct(st.playerHP, st.playerHPMax);
        var sPct = getPct(st.super, BJZ.cfg.super.max);
        var bPct = getPct(st.bossHP, st.bossHPMax);
        var hpNan = (!isFinite(st.playerHP / st.playerHPMax));

        this.barsGfx.clear();
        this.drawBar(30, 6, 120, 10, hPct, 0xff3333, 0x330000); 
        this.drawBar(30, 20, 80, 10, sPct, 0xffaa00, 0x332200); 
        this.drawBar(560, 6, 220, 10, bPct, 0xcc2222, 0x330000); 

        var hpW = Math.max(0, Math.round(120 * hPct));
        var bossW = Math.max(0, Math.round(220 * bPct));
        var barOk = (st.playerHP > 0 ? hpW >= 1 : true) && (st.bossHP > 0 ? bossW >= 1 : true);

        // --- HUD DEBUG (10Hz) ---
        this._dbgAccMs += delta;
        if (this._dbgAccMs >= 100) {
            this._dbgAccMs = 0;
            if (!this._showDebug) return;

            var joyId = this._hudPointers.joyId;
            var a1Id = this.btnA1.pointerId;
            var ptrConflict = [joyId, a1Id, this.btnA2.pointerId, this.btnSuper.pointerId].filter(x => x!==null).length > new Set([joyId, a1Id, this.btnA2.pointerId, this.btnSuper.pointerId].filter(x => x!==null)).size;
            var canvas = this.game.canvas;
            
            var line1 = "HP:" + Math.round(hPct*100) + "% | BOSS:" + Math.round(bPct*100) + "% | BAR_OK:" + (barOk?1:0);
            var line2 = "TRACE:" + st.debug.attackTrace + " | PTR:" + (ptrConflict ? "CONFLICT!" : "OK");
            var line3 = "CANVAS:" + canvas.width + "x" + canvas.height + " | O:Toggle Overlay";
            var line4 = "JUICE:" + (cfg.juice.enabled ? "ON" : "OFF") + " | HITSTOP:" + Math.round(st.hitstopMs) + "ms (" + (st.hitstopReason || "-") + ")";
            
            var e1 = st.enemies.e1; var e2 = st.enemies.e2;
            var varietyOk = (e1 && e2 && e1.typeId !== e2.typeId && e1.hpMax !== e2.hpMax) ? "VARIETY_OK" : "VARIETY_ERR";
            var line5 = "E1:" + (e1?e1.typeId:'-') + " HP:" + (e1?e1.hp:'-') + " SPD:" + (e1?e1.moveSpeedX:'-') + " DMG:" + (e1?e1.touchDamage:'-');
            var line6 = "E2:" + (e2?e2.typeId:'-') + " HP:" + (e2?e2.hp:'-') + " SPD:" + (e2?e2.moveSpeedX:'-') + " DMG:" + (e2?e2.touchDamage:'-') + " | " + varietyOk;

            // PROMPT 8H: Parallax Readout
            var sp = st.spawn;
            var now = this.time.now;
            var pSpd = cfg.spawning.parallax.speeds;
            var camX = Math.round(st.debug.camX || 0);
            var line7 = "CAM:" + camX + " PL:" + st.debug.playerX + " | WAVE:" + sp.wave + " PH:" + sp.wavePhase;
            var line8 = "PARALLAX (F/M/N): " + Math.round(camX*pSpd.far) + "/" + Math.round(camX*pSpd.mid) + "/" + Math.round(camX*pSpd.near);
            var line9 = "ALIVE:" + sp.aliveCount + "/" + cfg.spawning.maxAlive + " | GUARD:" + st.debug.aliveGuardOk + " | HUD:V8H";

            this.debugOverlayText.setText(line1 + "\n" + line2 + "\n" + line3 + "\n" + line4 + "\n" + line5 + "\n" + line6 + "\n" + line7 + "\n" + line8 + "\n" + line9);
        }
    },
    drawBar: function(x, y, w, h, pct, f, b) {
        pct = Phaser.Math.Clamp(isFinite(pct) ? pct : 0, 0, 1);
        this.barsGfx.fillStyle(b, 1); this.barsGfx.fillRect(x, y, w, h); 
        if (pct > 0) { 
            this.barsGfx.fillStyle(f, 1); 
            var fillW = Math.max(1, Math.round(w * pct));
            this.barsGfx.fillRect(x, y, fillW, h); 
            
            // PROMPT 8: Visual Marker
            if (BJZ.cfg.dev.barMarkersOn) {
                this.barsGfx.fillStyle(0xffffff, 1);
                this.barsGfx.fillRect(x + fillW - 2, y + h/2 - 1, 3, 3);
            }
        } 
        this.barsGfx.lineStyle(1, 0xfff, 0.4); this.barsGfx.strokeRect(x, y, w, h); 
    }
});

var config = {
    type: Phaser.AUTO, width: 800, height: 450, pixelArt: true, parent: document.body,
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: BJZ.cfg.dev.arcadeDebug } },
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    input: { activePointers: 3 },
    scene: [GameScene, HudScene]
};
new Phaser.Game(config);
</script>
</body>
</html>

